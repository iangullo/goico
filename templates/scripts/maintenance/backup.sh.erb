#!/bin/bash
set -euo pipefail

<%= comment_box "Backup Script for #{app_name}" %>

# Configuration
APP_NAME="<%= app_name %>"
BACKUP_DIR="<%= @options[:backup_path] || "/var/backups/#{app_name}" %>"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/${APP_NAME}_${TIMESTAMP}.backup"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1" >&2
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARN:${NC} $1"
}

# Ensure backup directory exists
setup_backup_dir() {
    log "Setting up backup directory: $BACKUP_DIR"
    mkdir -p "$BACKUP_DIR"
    chmod 700 "$BACKUP_DIR"

    <% if user && group %>
    chown <%= user %>:<%= group %> "$BACKUP_DIR"
    <% end %>
}

# Database backup function
backup_database() {
    log "Starting database backup..."

    case "<%= @analysis[:database] %>" in
        postgresql)
            backup_postgresql
            ;;
        mysql)
            backup_mysql
            ;;
        sqlite)
            backup_sqlite
            ;;
        *)
            error "Unsupported database type: <%= @analysis[:database] %>"
            exit 1
            ;;
    esac
}

backup_postgresql() {
    local db_file="${BACKUP_FILE}.pgdump"

    log "Backing up PostgreSQL database..."
    sudo -u <%= @options[:db_user] || app_name %> pg_dump --verbose --clean --no-owner --no-acl --format=custom \
        <%= app_name %>_production > "$db_file"

    if [ $? -eq 0 ]; then
        log "PostgreSQL backup completed: $db_file"
        echo "database:${db_file}" >> "${BACKUP_FILE}.manifest"
    else
        error "PostgreSQL backup failed"
        exit 1
    fi
}

backup_mysql() {
    local db_file="${BACKUP_FILE}.sql"

    log "Backing up MySQL database..."
    mysqldump --single-transaction --quick --lock-tables=false \
        -u <%= @options[:db_user] || app_name %> \
        -p"<%= @options[:db_password] || 'please-set-password' %>" \
        <%= app_name %>_production > "$db_file"

    if [ $? -eq 0 ]; then
        log "MySQL backup completed: $db_file"
        echo "database:${db_file}" >> "${BACKUP_FILE}.manifest"
    else
        error "MySQL backup failed"
        exit 1
    fi
}

backup_sqlite() {
    local db_file="${BACKUP_FILE}.sqlite3"
    local source_db="<%= app_install_path %>/production.sqlite3"

    if [ -f "$source_db" ]; then
        log "Backing up SQLite database..."
        cp "$source_db" "$db_file"
        log "SQLite backup completed: $db_file"
        echo "database:${db_file}" >> "${BACKUP_FILE}.manifest"
    else
        warn "SQLite database not found: $source_db"
    fi
}

# Application files backup
backup_application() {
    log "Backing up application configuration..."
    local app_backup="${BACKUP_FILE}.app.tar.gz"

    tar -czf "$app_backup" \
        -C "<%= app_install_path %>" \
        config \
        vendor/bundle \
        --exclude="*.log" \
        --exclude="tmp/cache" \
        --exclude="node_modules"

    if [ $? -eq 0 ]; then
        log "Application backup completed: $app_backup"
        echo "application:${app_backup}" >> "${BACKUP_FILE}.manifest"
    else
        error "Application backup failed"
        exit 1
    fi
}

# Cleanup old backups
cleanup_old_backups() {
    log "Cleaning up backups older than 30 days..."
    find "$BACKUP_DIR" -name "${APP_NAME}_*.backup.*" -mtime +30 -delete
    find "$BACKUP_DIR" -name "${APP_NAME}_*.manifest" -mtime +30 -delete
}

# Main backup function
main() {
    log "Starting backup process for $APP_NAME"

    setup_backup_dir
    backup_database
    backup_application

    # Create backup manifest
    echo "backup_timestamp: $TIMESTAMP" > "${BACKUP_FILE}.manifest"
    echo "app_name: $APP_NAME" >> "${BACKUP_FILE}.manifest"
    echo "app_version: <%= @options[:version] || '1.0.0' %>" >> "${BACKUP_FILE}.manifest"
    echo "database_type: <%= @analysis[:database] %>" >> "${BACKUP_FILE}.manifest"

    cleanup_old_backups

    log "Backup completed successfully: ${BACKUP_FILE}.manifest"

    # Display backup size
    local total_size=$(du -sh "$BACKUP_DIR" | cut -f1)
    log "Total backup storage used: $total_size"
}

# Handle signals
trap 'error "Backup interrupted"; exit 1' INT TERM

# Run main function
main "$@"